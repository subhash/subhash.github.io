<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Disclojures : ">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Disclojures</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/subhash">View on GitHub</a>

          <h1 id="project_title">Disclojures</h1>
          <h2 id="project_tagline"></h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="collections-and-sequences" class="anchor" href="#collections-and-sequences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Collections and Sequences</h3>

<p><img class="emoji" title=":date:" alt=":date:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c5.png" height="20" width="20" align="absmiddle"> 2 Jan 2015</p>

<p>Clojure collections are literally a handful and distinguishing between the various types is tricky. Let's take a shot at it by studying the various collection functions:</p>

<p><strong><code>coll?</code></strong> tells us which ones are valid collections. Expectedly, scalars like numbers and keywords are not collections. Strings are also not collections, but they can be easily converted to become collections</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">map</span> coll? [ '(<span class="pl-c1">:foo</span>) [<span class="pl-c1">:foo</span>] #{<span class="pl-c1">:foo</span>} {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} <span class="pl-c1">:foo</span> <span class="pl-c1">1</span> <span class="pl-s1"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ])
(<span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span>)</pre></div>

<p><strong><code>counted?</code></strong> validates those collections that possibly be counted. Understandably, the ones that cannot be counted are the lazy sequences which may be infinite. Interestingly, sequence functions like <code>map</code>, <code>filter</code> etc. return lazy sequences which cannot be counted.</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">map</span> counted? [ [<span class="pl-c1">:foo</span>] '(<span class="pl-c1">:foo</span>) {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} #{<span class="pl-c1">:foo</span>} (<span class="pl-en">range</span>) (<span class="pl-en">map</span> identity []) ])
(<span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span>)</pre></div>

<p><strong><code>associative?</code></strong> prefers those collections which are mapped in the form of <code>key:value</code> - namely, maps and vectors. In vectors, the mapping is from the element's index to itself. Sets are a trivial mapping from the element to itself and so are not considered associative. Lists and (lazy) sequences are accessed linearly and therefore, the concept of an index does not apply to them</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">map</span> associative? [[<span class="pl-c1">:foo</span>] '(<span class="pl-c1">:foo</span>) {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} #{<span class="pl-c1">:foo</span>} (<span class="pl-en">range</span>) ])
(<span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span>)</pre></div>

<p><strong><code>sequential?</code></strong> collections are those that can possibly be accessed in a linear order. Maps and sets don't quality because they have no defined order of access. </p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">map</span> sequential? [[<span class="pl-c1">:foo</span>] '(<span class="pl-c1">:foo</span>) {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} #{<span class="pl-c1">:foo</span>} (<span class="pl-en">range</span>) ])
(<span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span> <span class="pl-c1">true</span>)</pre></div>

<p>A collection is simply a bag of values. It is useful to be able to deal with the different kinds of collections from a common abstraction. Towards this, Clojure defines a "list-like" abstraction called <code>sequence</code>. This is similar to lists in that it is accessed linearly using <code>first</code> and <code>rest</code>. It is possible to create a <code>sequence</code> from any <code>collection</code> by calling <code>seq</code> on it. Such a sequence would always be sequential and non-associative. In fact, most collection APIs like <code>map</code>, <code>filter</code>, <code>take</code> etc call <code>seq</code> on the parameter before working on them. This is why all these APIs work consistently on all collections.</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">map</span> (<span class="pl-en">comp</span> sequential? seq) [[<span class="pl-c1">:foo</span>] '(<span class="pl-c1">:foo</span>) {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} #{<span class="pl-c1">:foo</span>} (<span class="pl-en">range</span>) ])
(<span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span>)
user=&gt; (<span class="pl-en">map</span> (<span class="pl-en">comp</span> associative? seq) [[<span class="pl-c1">:foo</span>] '(<span class="pl-c1">:foo</span>) {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} #{<span class="pl-c1">:foo</span>} (<span class="pl-en">range</span>) ])
(<span class="pl-c1">false</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span>)</pre></div>

<p><code>seq</code> also works on strings and other non-collections like Java arrays etc. The useful thing about <code>seq</code> is that it returns <code>nil</code> for empty collections and <code>nil</code>. Therefore, we have something like:</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-s">let</span> [a []]
         (<span class="pl-s">if</span> (<span class="pl-en">seq</span> a)
           (<span class="pl-en">first</span> a)
           <span class="pl-c1">:nothing-to-do</span>))
:nothing-to-do</pre></div>

<p>When <code>seq</code> is called on a collection, we get a specific implementation of sequence that presents a "list-view" of the collection. Since <code>list</code> is already a concrete implementation of sequence, it returns itself</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">doseq</span> [c [[<span class="pl-c1">:foo</span>] '(<span class="pl-c1">:foo</span>) {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} #{<span class="pl-c1">:foo</span>} (<span class="pl-en">range</span>) ]] (<span class="pl-en">println</span> (<span class="pl-en">class</span> c) <span class="pl-s1"><span class="pl-pds">"</span>-&gt;<span class="pl-pds">"</span></span> (<span class="pl-en">class</span> (<span class="pl-en">seq</span> c))))
clojure.lang.PersistentVector -&gt; clojure.lang.PersistentVector$ChunkedSeq
clojure.lang.PersistentList -&gt; clojure.lang.PersistentList
clojure.lang.PersistentArrayMap -&gt; clojure.lang.PersistentArrayMap$Seq
clojure.lang.PersistentHashSet -&gt; clojure.lang.APersistentMap$KeySeq
clojure.lang.LazySeq -&gt; clojure.lang.ChunkedCons
<span class="pl-c1">nil</span></pre></div>

<hr>

<h3>
<a id="clojure-tips--tricks-1-contains" class="anchor" href="#clojure-tips--tricks-1-contains" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clojure tips &amp; tricks #1: contains?</h3>

<p><img class="emoji" title=":date:" alt=":date:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c5.png" height="20" width="20" align="absmiddle"> 26 Dec 2014</p>

<p>You want to check if a set contains a certain element? Easy peasy ...</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">contains?</span> #{<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>} <span class="pl-c1">:foo</span>)
<span class="pl-c1">true</span></pre></div>

<p>How about a map?</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">contains?</span> {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span> <span class="pl-c1">:bar</span> <span class="pl-c1">2</span>} <span class="pl-c1">:foo</span>)
<span class="pl-c1">true</span></pre></div>

<p>Should work for vectors too, right?</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">contains?</span> [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>] <span class="pl-c1">:foo</span>)
<span class="pl-c1">false</span></pre></div>

<p>Nope. That does not work because <code>contains?</code> checks for the presence of keys, not values. And when you think about it, the keys for a vector are its indices. This is because a vector is strictly ordered and the key <code>1</code> should correspond to the second element, if any.</p>

<div class="highlight highlight-clojure"><pre>(<span class="pl-en">contains?</span> [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>] <span class="pl-c1">1</span>)
<span class="pl-c1">true</span></pre></div>

<p>This allows the <code>contains?</code> function to perform in constant or logarithmic time by searching only within the key indices.</p>

<p>Clojure provides a different function to check for values in a collection.</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">some</span> #(<span class="pl-en">=</span> % <span class="pl-c1">:foo</span>) [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>])
<span class="pl-c1">true</span></pre></div>

<p>Or even better:</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">some</span> #{<span class="pl-c1">:foo</span>} [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>])  <span class="pl-c">; a set acts as a predicate </span>
:foo <span class="pl-c">; a truthy value</span></pre></div>

<p>That might give you yet another idea</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">(set</span> [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>]) <span class="pl-c1">:foo</span>)
:foo
user=&gt; (<span class="pl-en">(set</span> [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>]) <span class="pl-c1">:doo</span>)
<span class="pl-c1">nil</span></pre></div>

<hr>

<h3>
<a id="hello-world" class="anchor" href="#hello-world" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello World!</h3>

<p><img class="emoji" title=":date:" alt=":date:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c5.png" height="20" width="20" align="absmiddle"> 21 Dec 2014</p>

<p>I have always had a crush on Clojure and now, I finally summoned the courage to ask her out on a date. You'll have to wait to see how the saga ends ..</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
