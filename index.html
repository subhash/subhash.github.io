<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Disclojures by subhash</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Disclojures</h1>
        <p class="header"></p>



        <ul>
          <li><a class="buttons github" href="https://github.com/subhash">GitHub Profile</a></li>
        </ul>

      </header>
      <section>
        <h3>
<a id="collections-and-sequences" class="anchor" href="#collections-and-sequences" aria-hidden="true"><span class="octicon octicon-link"></span></a>Collections and Sequences</h3>

<p><img class="emoji" title=":date:" alt=":date:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c5.png" height="20" width="20" align="absmiddle"> 2 Jan 2015</p>

<p>Clojure collections are literally a handful and clearly distinguishing between the various types is extremely important. Let's take a shot at it by studying the various properties:</p>

<p>A collection is simply a bag of values. <code>coll?</code> tells us which ones are valid collections. Expectedly, scalars like numbers and keywords are not collections. Strings are also not collections, but they can be easily converted to become collections</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">map</span> coll? [ '(<span class="pl-c1">:foo</span>) [<span class="pl-c1">:foo</span>] #{<span class="pl-c1">:foo</span>} {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} <span class="pl-c1">:foo</span> <span class="pl-c1">1</span> <span class="pl-s1"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> ])
(<span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span>)</pre></div>

<p><code>counted?</code> validates those collections that be possibly counted. Understandably, the ones that cannot be counted are the lazy sequences which may be infinite. Interestingly, sequence functions like <code>map</code>, <code>filter</code> etc. return lazy sequences which cannot be counted.</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">map</span> counted? [ [<span class="pl-c1">:foo</span>] '(<span class="pl-c1">:foo</span>) {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} #{<span class="pl-c1">:foo</span>} (<span class="pl-en">range</span>) (<span class="pl-en">map</span> identity []) ])
(<span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span>)</pre></div>

<p><code>associative?</code> prefers those collections which are mapped in the form of <code>key:value</code> - namely, maps and vectors. In vectors, the mapping is from the element's index to itself. Sets are a trivial mapping from the element to itself and so are not considered associative. Lists and (lazy) sequences are accessed linearly and therefore, the concept of an index does not apply to them</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">map</span> associative? [[<span class="pl-c1">:foo</span>] '(<span class="pl-c1">:foo</span>) {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span>} #{<span class="pl-c1">:foo</span>} (<span class="pl-en">range</span>) ])
(<span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">true</span> <span class="pl-c1">false</span> <span class="pl-c1">false</span>)</pre></div>

<hr>

<h3>
<a id="clojure-tips--tricks-1-contains" class="anchor" href="#clojure-tips--tricks-1-contains" aria-hidden="true"><span class="octicon octicon-link"></span></a>Clojure tips &amp; tricks #1: contains?</h3>

<p><img class="emoji" title=":date:" alt=":date:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c5.png" height="20" width="20" align="absmiddle"> 26 Dec 2014</p>

<p>You want to check if a set contains a certain element? Easy peasy ...</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">contains?</span> #{<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>} <span class="pl-c1">:foo</span>)
<span class="pl-c1">true</span></pre></div>

<p>How about a map?</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">contains?</span> {<span class="pl-c1">:foo</span> <span class="pl-c1">1</span> <span class="pl-c1">:bar</span> <span class="pl-c1">2</span>} <span class="pl-c1">:foo</span>)
<span class="pl-c1">true</span></pre></div>

<p>Should work for vectors too, right?</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">contains?</span> [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>] <span class="pl-c1">:foo</span>)
<span class="pl-c1">false</span></pre></div>

<p>Nope. That does not work because <code>contains?</code> checks for the presence of keys, not values. And when you think about it, the keys for a vector are its indices. This is because a vector is strictly ordered and the key <code>1</code> should correspond to the second element, if any.</p>

<div class="highlight highlight-clojure"><pre>(<span class="pl-en">contains?</span> [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>] <span class="pl-c1">1</span>)
<span class="pl-c1">true</span></pre></div>

<p>This allows the <code>contains?</code> function to perform in constant or logarithmic time by searching only within the key indices.</p>

<p>Clojure provides a different function to check for values in a collection.</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">some</span> #(<span class="pl-en">=</span> % <span class="pl-c1">:foo</span>) [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>])
<span class="pl-c1">true</span></pre></div>

<p>Or even better:</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">some</span> #{<span class="pl-c1">:foo</span>} [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>])  <span class="pl-c">; a set acts as a predicate </span>
:foo <span class="pl-c">; a truthy value</span></pre></div>

<p>That might give you yet another idea</p>

<div class="highlight highlight-clojure"><pre>user=&gt; (<span class="pl-en">(set</span> [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>]) <span class="pl-c1">:foo</span>)
:foo
user=&gt; (<span class="pl-en">(set</span> [<span class="pl-c1">:foo</span> <span class="pl-c1">:bar</span>]) <span class="pl-c1">:doo</span>)
<span class="pl-c1">nil</span></pre></div>

<hr>

<h3>
<a id="hello-world" class="anchor" href="#hello-world" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hello World!</h3>

<p><img class="emoji" title=":date:" alt=":date:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f4c5.png" height="20" width="20" align="absmiddle"> 21 Dec 2014</p>

<p>I have always had a crush on Clojure and now, I finally summoned the courage to ask her out on a date. You'll have to wait to see how the saga ends ..</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="http://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>
