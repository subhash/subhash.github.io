{"name":"Disclojures","tagline":"","body":"### Collections and Sequences\r\n:date: 2 Jan 2015\r\n\r\nClojure collections are literally a handful and clearly distinguishing between the various types is extremely important. Let's take a shot at it by studying the various properties:\r\n\r\nA collection is simply a bag of values. `coll?` tells us which ones are valid collections. Expectedly, scalars like numbers and keywords are not collections. Strings are also not collections, but they can be easily converted to become collections\r\n```clojure\r\nuser=> (map coll? [ '(:foo) [:foo] #{:foo} {:foo 1} :foo 1 \"foo\" ])\r\n(true true true true false false false)\r\n```\r\n\r\n`counted?` validates those collections that be possibly counted. Understandably, the ones that cannot be counted are the lazy sequences which may be infinite. Interestingly, sequence functions like `map`, `filter` etc. return lazy sequences which cannot be counted.\r\n\r\n```clojure\r\nuser=> (map counted? [ [:foo] '(:foo) {:foo 1} #{:foo} (range) (map identity []) ])\r\n(true true true true false false)\r\n``` \r\n\r\n`associative?` prefers those collections which are mapped in the form of `key:value` - namely, maps and vectors. In vectors, the mapping is from the element's index to itself. Sets are a trivial mapping from the element to itself and so are not considered associative. Lists and (lazy) sequences are accessed linearly and therefore, the concept of an index does not apply to them\r\n\r\n```clojure\r\nuser=> (map associative? [[:foo] '(:foo) {:foo 1} #{:foo} (range) ])\r\n(true false true false false)\r\n``` \r\n    \r\n----\r\n    \r\n### Clojure tips & tricks #1: contains?\r\n:date: 26 Dec 2014\r\n\r\nYou want to check if a set contains a certain element? Easy peasy ...\r\n```clojure\r\nuser=> (contains? #{:foo :bar} :foo)\r\ntrue\r\n```\r\nHow about a map?\r\n```clojure\r\nuser=> (contains? {:foo 1 :bar 2} :foo)\r\ntrue\r\n```\r\nShould work for vectors too, right?\r\n```clojure\r\nuser=> (contains? [:foo :bar] :foo)\r\nfalse\r\n```\r\nNope. That does not work because `contains?` checks for the presence of keys, not values. And when you think about it, the keys for a vector are its indices. This is because a vector is strictly ordered and the key `1` should correspond to the second element, if any.\r\n```clojure\r\n(contains? [:foo :bar] 1)\r\ntrue\r\n```\r\nThis allows the `contains?` function to perform in constant or logarithmic time by searching only within the key indices.\r\n\r\nClojure provides a different function to check for values in a collection.\r\n```clojure\r\nuser=> (some #(= % :foo) [:foo :bar])\r\ntrue\r\n```\r\nOr even better:\r\n```clojure\r\nuser=> (some #{:foo} [:foo :bar])  ; a set acts as a predicate \r\n:foo ; a truthy value\r\n```\r\n\r\nThat might give you yet another idea\r\n```clojure\r\nuser=> ((set [:foo :bar]) :foo)\r\n:foo\r\nuser=> ((set [:foo :bar]) :doo)\r\nnil\r\n```    \r\n    \r\n----    \r\n\r\n### Hello World! \r\n:date: 21 Dec 2014\r\n\r\nI have always had a crush on Clojure and now, I finally summoned the courage to ask her out on a date. You'll have to wait to see how the saga ends ..","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}