{"name":"Disclojures","tagline":"","body":"### Clojure tips & tricks #1: contains?\r\n:date: 26 Dec 2014\r\n\r\nYou want to check if a set contains a certain element? Easy peasy ...\r\n```clojure\r\nuser=> (contains? #{:foo :bar} :foo)\r\ntrue\r\n```\r\nHow about a map?\r\n```clojure\r\nuser=> (contains? {:foo 1 :bar 2} :foo)\r\ntrue\r\n```\r\nShould work for vectors too, right?\r\n```clojure\r\nuser=> (contains? [:foo :bar] :foo)\r\nfalse\r\n```\r\nNope. That does not work because `contains?` checks for the presence of keys, not values. And when you think about it, the keys for a vector are its indices. This is because a vector is strictly ordered and the key `1` should correspond to the second element, if any.\r\n```clojure\r\n(contains? [:foo :bar] 1)\r\ntrue\r\n```\r\nThis allows the `contains?` function to perform in constant or logarithmic time by searching only within the key indices.\r\n\r\nClojure provides a different function to check for values in a collection.\r\n```clojure\r\nuser=> (some #(= % :foo) [:foo :bar])\r\ntrue\r\n```\r\nOr even better:\r\n```clojure\r\nuser=> (some #{:foo} [:foo :bar])  ; a set acts as a predicate \r\n:foo ; a truthy value\r\n```\r\n\r\nThat might give you yet another idea\r\n```clojure\r\nuser=> ((set [:foo :bar]) :foo)\r\n:foo\r\nuser=> ((set [:foo :bar]) :doo)\r\nnil\r\n```    \r\n    \r\n----    \r\n\r\n### Hello World! \r\n:date: 21 Dec 2014\r\n\r\nI have always had a crush on Clojure and now, I finally summoned the courage to ask her out on a date. You'll have to wait to see how the saga ends ..","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}