{"name":"Disclojures","tagline":"","body":"### Clojure Everywhere: Om, Pedestal and Datomic\r\n:date: 9 Feb 2015\r\n\r\nIt is not everyday when you encounter a programming language which can be used all over the stack - in the client, server and DB. This fact fascinates me to no end and [Clojure Everywhere](https://github.com/subhash/clj-stack) is a result of that fascination. It is a tutorial-slash-sample-project that guides a newbie to the world of possibilities in Clojure (hopefully :smile:). Enjoy!\r\n\r\n\r\n### Datomic: It turtles all the way down!\r\n:date: 24 Jan 2015\r\n\r\nWe know that the way to create an attribute is Datomic is by running a transaction with a map like this:\r\n```clojure\r\n{:db/id #db/id[:db.part/db]\r\n :db/ident :community/name\r\n :db/valueType :db.type/string\r\n :db/cardinality :db.cardinality/one\r\n :db/fulltext true\r\n :db/doc \"A community's name\"\r\n :db.install/_attribute :db.part/db}\r\n```\r\n\r\nWe also know that the `:db.install/_attribute` is a back-reference to the `:db.part/db` entity which is responsible for keeping track of all the attributes in the system. Does that mean one can easily query all the attributes in the system?\r\n\r\n```clojure\r\n; datomic REPL\r\nuser=> (use '[datomic.api :only [q db] :as d])\r\nuser=> (def uri \"datomic:mem://disclojures\")\r\nuser=> (d/create-database uri)\r\nuser=> (def conn (d/connect uri))\r\nuser=> (q '[:find [?n ...] :where [:db.part/db :db.install/attribute ?a] [?a :db/ident ?n]] (db conn))\r\n[:db/code :fressian/tag :db/index :db/doc :db/lang :db.excise/before :db/fn :db.install/function :db.excise/beforeT :db/excise :db/cardinality :db.install/valueType :db.install/partition :db/txInstant :db/valueType :db.excise/attrs :db/unique :db.alter/attribute :db/ident :db/noHistory :db.install/attribute :db/isComponent :db/fulltext]\r\n```\r\n\r\nYes, that's right! All the system attributes (plus any others you may have defined) are modeled as values of the attribute `:db.install/attribute` of the entity `:db.part/db`. Now, that would mean that `:db.install/attribute` would be defined someplace, right? \r\n\r\n```clojure\r\nuser=> (q '[:find (pull ?a [*]) :where [?a :db/ident :db.install/attribute]] (db conn))\r\n[[{:db/id 13, :db/ident :db.install/attribute, :db/valueType {:db/id 20}, :db/cardinality {:db/id 36}, :db/doc \"System attribute with type :db.type/ref. Asserting this attribute on :db.part/db with value v will install v as an attribute.\"}]]\r\n```\r\n\r\nIt is indeed an attribute, but the type and cardinality information is hiding behind opaque ids. No worries, entity API to the rescue!\r\n\r\n```clojure\r\nuser=> (-> (db conn) (d/entity 36) (:db/ident))\r\n:db.cardinality/many\r\nuser=> (-> (db conn) (d/entity 20) (:db/ident))\r\n:db.type/ref\r\n```\r\n\r\nThat makes sense. `:db.install/attribute` is a `ref` because it \"points\" to other attribute definitions and it's cardinality is `many` obviously because there are \"many\" attributes. Now, what about `:db.type/ref`?\r\n\r\n\r\n```clojure\r\nuser=>  (q '[:find (pull ?a [*]) :where [?a :db/ident :db.type/ref ]] (db conn))\r\n[[{:db/id 20, :db/ident :db.type/ref, :fressian/tag :ref, :db/doc \"Value type for references. All references from one entity to another are through attributes with this value type.\"}]]\r\n```\r\n\r\nIt turns out that `:db.type/ref` is one of many basic \"built-in\" entities from which other definitions are based on. Here are some basic attributes in Datomic:\r\n\r\n```clojure\r\nuser=> (map #(-> (db conn) (d/entity %) (:db/ident)) (take 40 (range)))\r\n(:db.part/db :db/add :db/retract :db.part/tx :db.part/user nil nil nil nil nil :db/ident :db.install/partition :db.install/valueType :db.install/attribute :db.install/function :db/excise :db.excise/attrs :db.excise/beforeT :db.excise/before :db.alter/attribute :db.type/ref :db.type/keyword :db.type/long :db.type/string :db.type/boolean :db.type/instant :db.type/fn :db.type/bytes nil nil nil nil nil nil nil :db.cardinality/one :db.cardinality/many :db.unique/value :db.unique/identity :fressian/tag)\r\n```\r\n\r\nIt is interesting to see how Datomic's meta-system, at the very bottom, consists only of entities or facts. These basic entities are used to create a type system and instrument attribute definitions. Later, the user refers to the type entities to define attributes, which are themselves entities. \r\n\r\n----\r\n----\r\n----\r\n----\r\n\r\n### 4clojure.com FTW!\r\n:date: 12 Jan 2015\r\n\r\nThis is a great resource for someone starting with Clojure. The site presents problems (of varying difficulty) and provides test cases to check for all sorts of edge-cases (and algorithmic complexity too!). The code golf feature challenges you to arrive at the shortest possible solution. Though some may be inspired to take it down the [Brainf**k](http://en.wikipedia.org/wiki/Brainfuck) route, this can also help you find the most idiomatic way to express yourself in Clojure. May the force be with you!\r\n\r\n[Yours truly](https://www.4clojure.com/user/subhashgo) is on rank 328 (and climbing). \r\n\r\n### Collections and Sequences\r\n:date: 2 Jan 2015\r\n\r\nClojure collections are literally a handful and distinguishing between the various types is tricky. Let's take a shot at it by studying the various collection functions:\r\n\r\n**`coll?`** tells us which ones are valid collections. Expectedly, scalars like numbers and keywords are not collections. Strings are also not collections, but they can be easily converted to become collections\r\n```clojure\r\nuser=> (map coll? [ '(:foo) [:foo] #{:foo} {:foo 1} :foo 1 \"foo\" ])\r\n(true true true true false false false)\r\n```\r\n\r\n**`counted?`** validates those collections that possibly be counted. Understandably, the ones that cannot be counted are the lazy sequences which may be infinite. Interestingly, sequence functions like `map`, `filter` etc. return lazy sequences which cannot be counted.\r\n\r\n```clojure\r\nuser=> (map counted? [ [:foo] '(:foo) {:foo 1} #{:foo} (range) (map identity []) ])\r\n(true true true true false false)\r\n``` \r\n\r\n**`associative?`** prefers those collections which are mapped in the form of `key:value` - namely, maps and vectors. In vectors, the mapping is from the element's index to itself. Sets are a trivial mapping from the element to itself and so are not considered associative. Lists and (lazy) sequences are accessed linearly and therefore, the concept of an index does not apply to them\r\n\r\n```clojure\r\nuser=> (map associative? [[:foo] '(:foo) {:foo 1} #{:foo} (range) ])\r\n(true false true false false)\r\n``` \r\n\r\n**`sequential?`** collections are those that can possibly be accessed in a linear order. Maps and sets don't quality because they have no defined order of access. \r\n```clojure\r\nuser=> (map sequential? [[:foo] '(:foo) {:foo 1} #{:foo} (range) ])\r\n(true true false false true)\r\n```\r\n\r\nA collection is simply a bag of values. It is useful to be able to deal with the different kinds of collections from a common abstraction. Towards this, Clojure defines a \"list-like\" abstraction called `sequence`. This is similar to lists in that it is accessed linearly using `first` and `rest`. It is possible to create a `sequence` from any `collection` by calling `seq` on it. Such a sequence would always be sequential and non-associative. In fact, most collection APIs like `map`, `filter`, `take` etc call `seq` on the parameter before working on them. This is why all these APIs work consistently on all collections.\r\n```clojure\r\nuser=> (map (comp sequential? seq) [[:foo] '(:foo) {:foo 1} #{:foo} (range) ])\r\n(true true true true true)\r\nuser=> (map (comp associative? seq) [[:foo] '(:foo) {:foo 1} #{:foo} (range) ])\r\n(false false false false false)\r\n```\r\n\r\n`seq` also works on strings and other non-collections like Java arrays etc. The useful thing about `seq` is that it returns `nil` for empty collections and `nil`. Therefore, we have something like:\r\n```clojure\r\nuser=> (let [a []]\r\n         (if (seq a)\r\n           (first a)\r\n           :nothing-to-do))\r\n:nothing-to-do\r\n```\r\n\r\nWhen `seq` is called on a collection, we get a specific implementation of sequence that presents a \"list-view\" of the collection. Since `list` is already a concrete implementation of sequence, it returns itself\r\n\r\n```clojure\r\nuser=> (doseq [c [[:foo] '(:foo) {:foo 1} #{:foo} (range) ]] (println (class c) \"->\" (class (seq c))))\r\nclojure.lang.PersistentVector -> clojure.lang.PersistentVector$ChunkedSeq\r\nclojure.lang.PersistentList -> clojure.lang.PersistentList\r\nclojure.lang.PersistentArrayMap -> clojure.lang.PersistentArrayMap$Seq\r\nclojure.lang.PersistentHashSet -> clojure.lang.APersistentMap$KeySeq\r\nclojure.lang.LazySeq -> clojure.lang.ChunkedCons\r\nnil\r\n```\r\n    \r\n----\r\n    \r\n### Clojure tips & tricks #1: contains?\r\n:date: 26 Dec 2014\r\n\r\nYou want to check if a set contains a certain element? Easy peasy ...\r\n```clojure\r\nuser=> (contains? #{:foo :bar} :foo)\r\ntrue\r\n```\r\nHow about a map?\r\n```clojure\r\nuser=> (contains? {:foo 1 :bar 2} :foo)\r\ntrue\r\n```\r\nShould work for vectors too, right?\r\n```clojure\r\nuser=> (contains? [:foo :bar] :foo)\r\nfalse\r\n```\r\nNope. That does not work because `contains?` checks for the presence of keys, not values. And when you think about it, the keys for a vector are its indices. This is because a vector is strictly ordered and the key `1` should correspond to the second element, if any.\r\n```clojure\r\n(contains? [:foo :bar] 1)\r\ntrue\r\n```\r\nThis allows the `contains?` function to perform in constant or logarithmic time by searching only within the key indices.\r\n\r\nClojure provides a different function to check for values in a collection.\r\n```clojure\r\nuser=> (some #(= % :foo) [:foo :bar])\r\ntrue\r\n```\r\nOr even better:\r\n```clojure\r\nuser=> (some #{:foo} [:foo :bar])  ; a set acts as a predicate \r\n:foo ; a truthy value\r\n```\r\n\r\nThat might give you yet another idea\r\n```clojure\r\nuser=> ((set [:foo :bar]) :foo)\r\n:foo\r\nuser=> ((set [:foo :bar]) :doo)\r\nnil\r\n```    \r\n    \r\n----    \r\n\r\n### Hello World! \r\n:date: 21 Dec 2014\r\n\r\nI have always had a crush on Clojure and now, I finally summoned the courage to ask her out on a date. You'll have to wait to see how the saga ends ..","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}